{"task_id": "HumanEval_0_has_close_elements", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given list of numbers, are any two numbers closer to each other than\n// given threshold.\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::vector<float> temp;\n    float res;\n    int i = 0;\n    for(int i = 0; i < numbers.size(); i++) {\n        for(int j = 0; j < numbers.size(); j++) {", "canonical_solution": "            if(i != j) {", "suffix": "                res = numbers[i] - numbers[j];\n                temp.push_back(std::abs(res));\n            }\n        }\n    }\n    for(int i = 0; i < temp.size(); i++) {\n        if(temp[i] < threshold) {\n            return true;\n        }\n    }\n    return false;", "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"}
{"task_id": "HumanEval_100_make_a_pile", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> v;\n    int i;\n    for(i=0;i<n;i++)\n    {", "canonical_solution": "        v.push_back(n+2*i);", "suffix": "    }\n    return v;", "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"}
{"task_id": "HumanEval_101_words_string", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// For example:\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;", "canonical_solution": "  for (auto x : s) {", "suffix": "    if (x == ' ') {\n      if (word.size() > 0) {\n        words.push_back(word);\n        word.clear();\n      }\n    } else if (x == ',') {\n      if (word.size() > 0) {\n        words.push_back(word);\n        word.clear();\n      }\n    } else {\n      word.push_back(x);\n    }\n  }\n  if (word.size() > 0) {\n    words.push_back(word);\n  }\n  return words;", "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"}
{"task_id": "HumanEval_102_choose_num", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\nlong choose_num(long x, long y) {\n    for (long i = y; i >= x; i--) {\n        if (i % 2 == 0) {", "canonical_solution": "            return i;", "suffix": "        }\n    }\n    return -1;", "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"}
{"task_id": "HumanEval_104_unique_digits", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of positive integers x. return a sorted list of all \n// elements that hasn't any even digit.\n// Note: Returned list should be sorted in increasing order.\n// For example:\nstd::vector<long> unique_digits(std::vector<long> x) {\n    bool flag = true;\n    std::vector<long> res;\n    std::sort(x.begin(), x.end());\n    for(long i = 0; i < x.size(); i++) {\n        long n = x[i];\n        if(n < 10) {\n            res.push_back(n);", "canonical_solution": "        } else {", "suffix": "            while(n) {\n                if(n % 2 == 0) {\n                    flag = false;\n                    break;\n                }\n                n /= 10;\n            }\n            if(flag) res.push_back(x[i]);\n            flag = true;\n        }\n    }\n    return res;", "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"}
{"task_id": "HumanEval_105_by_length", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// If the array is empty, return an empty array:\n// If the array has any strange number ignore it:\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> res;\n    std::map<long, std::string> names = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n    std::sort(arr.begin(), arr.end());\n    for (long num : arr) {\n        if (names.find(num) != names.end()) {", "canonical_solution": "            res.push_back(names[num]);", "suffix": "        }\n    }\n    std::reverse(res.begin(), res.end());\n    return res;", "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"}
{"task_id": "HumanEval_106_f", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\nstd::vector<long> f(long n) {\n    std::vector<long> vec;\n    for(int i=1;i<=n;i++){\n        if(i%2==0){\n            long fact=1;\n            for(int j=1;j<=i;j++){\n                fact*=j;\n            }\n            vec.push_back(fact);\n        }", "canonical_solution": "        else{", "suffix": "            long sum=0;\n            for(int j=1;j<=i;j++){\n                sum+=j;\n            }\n            vec.push_back(sum);\n        }\n    }\n    return vec;", "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"}
{"task_id": "HumanEval_107_even_odd_palindrome", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        std::string s = std::to_string(i);\n        std::string rev = s;\n        std::reverse(rev.begin(), rev.end());\n        if (s == rev) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }", "canonical_solution": "    return std::make_tuple(even, odd);", "suffix": "", "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"}
{"task_id": "HumanEval_108_count_nums", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\nlong count_nums(std::vector<long> arr) {\n    int cnt=0;\n    for(auto i=arr.begin();i!=arr.end();i++){\n        int sum=0;\n        if(*i<0){\n            sum+=(*i)%10;\n            *i*=-1;\n        }\n        while(*i){\n            sum+=(*i)%10;\n            *i/=10;\n        }", "canonical_solution": "        if(sum>0)", "suffix": "            cnt++;\n    }\n    return cnt;", "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"}
{"task_id": "HumanEval_109_move_one_ball", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will be randomly ordered. Your task is to determine if\n// it is possible to get an array sorted in non-decreasing order by performing \n// the following operation on the given array:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the array by one\n// position in the right direction. The last element of the array will be moved to\n// the starting position in the array i.e. 0th index. \n// If it is possible to obtain the sorted array by performing the above operation\n// then return True else return False.\n// If the given array is empty then return True.\n// Note: The given list is guaranteed to have unique elements.\n// For Example:\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given array.\n// Explanation:It is not possible to get non-decreasing order for the given\n// array by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    // write your solution here\n    int n = arr.size();\n    if(n==0)\n        return true;", "canonical_solution": "    int count =0;", "suffix": "    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n            count++;\n    }\n    return count>1?false:true;", "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"}
{"task_id": "HumanEval_10_make_palindrome", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nstd::string make_palindrome(std::string string) {\n    if (string.empty()) {\n        return string;\n    }\n    // Find the longest suffix that is a palindrome.\n    std::string suffix = string;", "canonical_solution": "    std::reverse(suffix.begin(), suffix.end());", "suffix": "    std::string::size_type longest_suffix_len = string.size();\n    for (std::string::size_type suffix_len = string.size(); suffix_len > 0; suffix_len--) {\n        if (string.substr(string.size() - suffix_len) == suffix.substr(0, suffix_len)) {\n            longest_suffix_len = suffix_len;\n            break;\n        }\n    }\n    // Add the reverse of a string prefix before the palindromic suffix.\n    return string + suffix.substr(longest_suffix_len);", "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"}
{"task_id": "HumanEval_110_exchange", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// It is assumed that the input lists will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    std::vector<long> lst_even;\n    std::vector<long> lst_odd;\n    for (auto i : lst1) {\n        if (i % 2 == 0)\n            lst_even.push_back(i);\n        else\n            lst_odd.push_back(i);\n    }", "canonical_solution": "    for (auto i : lst2) {", "suffix": "        if (i % 2 == 0)\n            lst_even.push_back(i);\n        else\n            lst_odd.push_back(i);\n    }\n    if (lst_even.size() >= lst1.size())\n        return \"YES\";\n    else\n        return \"NO\";", "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"}
{"task_id": "HumanEval_111_histogram", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a dictionary\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> result;\n    // map of word to word count.\n    std::map<std::string,long> map;\n    std::stringstream ss(test);\n    std::string word;\n    std::string maxWord;\n    while(ss >> word) {\n        // increment the word in the map by 1.\n        map[word]++;\n        // store the max word and its count in a separate map called result.\n        if(map[word] > map[maxWord])\n            maxWord = word;\n    }\n    for(auto elem : map) {\n        if(elem.second == map[maxWord])\n            result[elem.first] = elem.second;\n    }", "canonical_solution": "    return result;", "suffix": "", "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"}
{"task_id": "HumanEval_112_reverse_delete", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and True/False for the check.\n// Example\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string temp;\n    for(int i=0;i<s.size();i++){\n        if(c.find(s[i])==std::string::npos){\n            temp.push_back(s[i]);", "canonical_solution": "        }", "suffix": "    }\n    s=temp;\n    for(int i=0;i<s.size()/2;i++){\n        if(s[i]!=s[s.size()-i-1]) return std::make_tuple(s,false);\n    }\n    return std::make_tuple(s,true);", "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"}
{"task_id": "HumanEval_113_odd_count", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    // make a vector of strings to store the count\n    std::vector<std::string> v;\n    for (std::string n : lst) {\n        int count = 0;\n        // loop through the string and if i % 2 != 0 add one to count", "canonical_solution": "        for (char &i : n) {", "suffix": "            if (i % 2 != 0)\n                count++;\n        }\n        // make a string to store\n        std::string s = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        // push the string to the vector\n        v.push_back(s);\n    }\n    return v;", "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"}
{"task_id": "HumanEval_114_minSubArraySum", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\n// Example\nlong minSubArraySum(std::vector<long> nums) {\n    long m = INT_MAX;\n    long sum = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        sum += nums[i];\n        m = std::min(m, sum);\n        if (sum > 0) sum = 0;\n    }", "canonical_solution": "    return m;", "suffix": "", "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"}
{"task_id": "HumanEval_115_max_fill", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Example 2:\n// Example 3:\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  // your code here\n  std::vector<long> total;\n  for(int i = 0; i < grid.size(); i++){\n    long sum = 0;\n    for(int j = 0; j < grid[i].size(); j++){\n      sum += grid[i][j];", "canonical_solution": "    }", "suffix": "    total.push_back(sum);\n  }\n  std::sort(total.begin(), total.end());\n  long count = 0;\n  for(int i = total.size() - 1; i >= 0; i--){\n    if(total[i] % capacity != 0){\n      count += (total[i] / capacity) + 1;\n    }\n    else{\n      count += total[i] / capacity;\n    }\n  }\n  return count;", "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"}
{"task_id": "HumanEval_116_sort_array", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::vector<std::pair<int, int>> tmp;\n  int n = arr.size();\n  for (int i = 0; i < n; i++) {\n    int ones = 0;\n    int x = arr[i];\n    if (x < 0)\n      x = -x;\n    while (x > 0) {\n      if (x % 2 == 1)", "canonical_solution": "        ones++;", "suffix": "      x = x / 2;\n    }\n    tmp.push_back(std::make_pair(ones, arr[i]));\n  }\n  std::sort(tmp.begin(), tmp.end());\n  for (int i = 0; i < n; i++) {\n    arr[i] = tmp[i].second;\n  }\n  return arr;", "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"}
{"task_id": "HumanEval_117_select_words", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::string word;\n    std::string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == ' ') {\n            if (count == n) {\n                result.push_back(word);\n            }\n            word = \"\";\n            count = 0;", "canonical_solution": "        } else {", "suffix": "            word += s[i];\n            if (consonants.find(tolower(s[i])) != std::string::npos) {\n                count++;\n            }\n        }\n    }\n    if (count == n) {\n        result.push_back(word);\n    }\n    return result;", "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"}
{"task_id": "HumanEval_118_get_closest_vowel", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\nstd::string get_closest_vowel(std::string word) {\n  \n  // You can use the following block to get a set of vowels\n  std::set<char> vowels{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::string vowels_found = \"\";\n  int min_dist = std::numeric_limits<int>::max();\n  char closest_vowel = ' ';\n  for (int i = 0; i < word.size(); i++) {\n    if (vowels.find(word[i]) != vowels.end()) {\n      // vowel found, check previous and next letter\n      if (i == 0 || i == word.size() - 1) continue;\n      if (vowels.find(word[i-1]) == vowels.end() && vowels.find(word[i+1]) == vowels.end()) {\n        int dist = word.size() - i;\n        if (dist < min_dist) {\n          min_dist = dist;\n          closest_vowel = word[i];\n        }\n      }\n    }\n  }\n  if (closest_vowel != ' ') vowels_found += closest_vowel;", "canonical_solution": "  return vowels_found;", "suffix": "", "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"}
{"task_id": "HumanEval_11_string_xor", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    if(a.size()!=b.size())\n        return result;\n    for(size_t i=0;i<a.size();i++)", "canonical_solution": "    {", "suffix": "        result.push_back((a[i]-'0')^(b[i]-'0')+'0');\n    }\n    return result;", "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"}
{"task_id": "HumanEval_120_maximum", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array arr of integers and a positive integer k, return a sorted list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// Example 2:\n// Example 3:\n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    // An initial, naive implementation.\n    if(k==0) return {};\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    int i=0;\n    for(int i=0; i<arr.size(); i++){\n        if(min_heap.size()<k){\n            min_heap.push(arr[i]);\n        }\n        else{\n            if(arr[i]>min_heap.top()){\n                min_heap.pop();\n                min_heap.push(arr[i]);", "canonical_solution": "            }", "suffix": "        }\n    }\n    while(!min_heap.empty()){\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;", "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"}
{"task_id": "HumanEval_121_solution", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\nlong solution(std::vector<long> lst) {\n    // Write your code here\n    long ans = 0;\n    int i = 0;\n    while(i < lst.size()){\n        if(lst[i]%2 == 1){\n            ans += lst[i];\n        }\n        i+=2;\n    }", "canonical_solution": "    return ans;", "suffix": "", "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"}
{"task_id": "HumanEval_122_add_elements", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    int sum = 0;\n    for(int i = 0; i < k; i++) {\n        if(arr[i] < 100) {\n            sum += arr[i];\n        }", "canonical_solution": "    }", "suffix": "    return sum;", "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"}
{"task_id": "HumanEval_123_get_odd_collatz", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> Collatz;\n    // This function must return a vector<long> containing the odd\n    // numbers in the Collatz sequence for n.\n    // Your code goes here.", "canonical_solution": "    ", "suffix": "    long k = n;\n    Collatz.push_back(k);\n    // Collatz(1) is [1].\n    if (k == 1) return Collatz;\n    while (k != 1) {\n        if (k % 2 == 0) {\n            k = k / 2;\n        } else {\n            k = 3 * k + 1;\n        }\n        Collatz.push_back(k);\n    }\n    // returned vector sorted in increasing order.\n    std::sort(Collatz.begin(), Collatz.end());\n    // filter odd number.\n    std::vector<long> res;\n    for (auto x : Collatz) {\n        if (x % 2 == 1) {\n            res.push_back(x);\n        }\n    }\n    return res;", "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"}
{"task_id": "HumanEval_124_valid_date", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns True if the date is valid otherwise False.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\nbool valid_date(std::string date) {\n    int month,day,year;\n    char a,b;\n    int len = date.length();\n    if(len != 10)\n        return false;\n    if(date[2] != '-' || date[5] != '-')\n        return false;\n    int d = sscanf(date.c_str(),\"%d%c%d%c%d\",&month,&a,&day,&b,&year);\n    if(d != 5)\n        return false;", "canonical_solution": "    if(month<1 || month>12)", "suffix": "        return false;\n    if(day<1 || day>31)\n        return false;\n    if(month == 2 && day>29)\n        return false;\n    if(month == 2 && day==29 && year%4 != 0)\n        return false;\n    if(month == 4 || month == 6 || month == 9 || month == 11)\n    {\n        if(day>30)\n            return false;\n    }\n    return true;", "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"}
{"task_id": "HumanEval_125_split_words", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    if (txt.find(' ') != std::string::npos) {\n        std::vector<std::string> words = std::vector<std::string>();\n        std::string word = std::string();\n        for (char c : txt) {\n            if (c == ' ') {\n                words.push_back(word);\n                word = std::string();\n            } else {\n                word += c;\n            }\n        }\n        words.push_back(word);\n        return Union_std_vector_std_string__long(words);\n    } else if (txt.find(',') != std::string::npos) {\n        std::vector<std::string> words = std::vector<std::string>();\n        std::string word = std::string();\n        for (char c : txt) {\n            if (c == ',') {\n                words.push_back(word);\n                word = std::string();\n            } else {\n                word += c;\n            }\n        }\n        words.push_back(word);\n        return Union_std_vector_std_string__long(words);", "canonical_solution": "    } else {", "suffix": "        int num_odd = 0;\n        for (char c : txt) {\n            if (c - 'a' >= 0 && c - 'a' < 26) {\n                if ((c - 'a') % 2 == 1) {\n                    num_odd += 1;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(num_odd);\n    }", "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"}
{"task_id": "HumanEval_126_is_sorted", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return False. Assume no negative numbers and only integers.\n// Examples\nbool is_sorted(std::vector<long> lst) {\n    long prev = -1;\n    long count = 0;\n    bool first = true;\n    for (long num : lst) {\n        if (first) {\n            first = false;\n        } else {\n            if (num < prev) {\n                return false;\n            }\n            if (num == prev) {\n                count++;\n                if (count > 1) {", "canonical_solution": "                    return false;", "suffix": "                }\n            } else {\n                count = 0;\n            }\n        }\n        prev = num;\n    }\n    return true;", "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"}
{"task_id": "HumanEval_127_intersection", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  std::vector<long> intervalList;\n  intervalList.push_back(std::get<0>(interval1));\n  intervalList.push_back(std::get<1>(interval1));\n  intervalList.push_back(std::get<0>(interval2));\n  intervalList.push_back(std::get<1>(interval2));\n  std::sort(intervalList.begin(), intervalList.end());\n  long lengthOfIntersection = intervalList[2] - intervalList[1];", "canonical_solution": "  if (lengthOfIntersection < 2) {", "suffix": "    return \"NO\";\n  }\n  for (long i = 2; i < lengthOfIntersection; i++) {\n    if (lengthOfIntersection % i == 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";", "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"}
{"task_id": "HumanEval_128_prod_signs", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long> prod_signs(std::vector<long> arr) {\n\t//your code here\n\t//return std::nullopt;\n\tif (arr.size() == 0)\n\t\treturn std::nullopt;\n\tlong prod = 1;\n\tfor (long i = 0; i < arr.size(); i++)", "canonical_solution": "\t{", "suffix": "\t\tif (arr[i] < 0)\n\t\t\tprod *= -1;\n\t\tif (arr[i] == 0)\n\t\t\treturn 0;\n\t}\n\tlong sum = 0;\n\tfor (long i = 0; i < arr.size(); i++)\n\t{\n\t\tsum += std::abs(arr[i]);\n\t}\n\treturn sum * prod;", "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"}
{"task_id": "HumanEval_12_longest", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of list of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input list is empty.\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n    std::vector<std::string>::iterator itr = std::max_element(strings.begin(), strings.end(), [](const std::string& str1, const std::string& str2) {\n        return str1.length() < str2.length();", "canonical_solution": "    });", "suffix": "    return std::optional<std::string>(*itr);", "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"}
{"task_id": "HumanEval_131_digits", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\nlong digits(long n) {\n    long product = 1;\n    long counter = 0;\n    while (n > 0) {\n        long temp = n % 10;", "canonical_solution": "        if (temp % 2 != 0) {", "suffix": "            product *= temp;\n            counter++;\n        }\n        n /= 10;\n    }\n    if (counter == 0) {\n        return 0;\n    }\n    return product;", "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"}
{"task_id": "HumanEval_133_sum_squares", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\nlong sum_squares(std::vector<float> lst) {\n  long result = 0;\n  for (int i = 0; i < lst.size(); i++) {", "canonical_solution": "    float tmp = std::ceil(lst[i]);", "suffix": "    result += tmp * tmp;\n  }\n  return result;", "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"}
{"task_id": "HumanEval_134_check_if_last_char_is_a_letter", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns True if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and False otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\nbool check_if_last_char_is_a_letter(std::string txt) {", "canonical_solution": "  return !txt.empty() && isalpha(txt.back()) && !isalpha(txt[txt.size() - 2]);", "suffix": "", "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"}
{"task_id": "HumanEval_135_can_arrange", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\n// Examples:\nlong can_arrange(std::vector<long> arr) {\n  if (arr.size() == 0) {\n    return -1;\n  }\n  long max_index = -1;\n  long max_seen = arr[0];\n  for (long i = 1; i < arr.size(); i++) {\n    if (arr[i] <= max_seen) {\n      max_index = i;\n    } else {\n      max_seen = arr[i];\n    }", "canonical_solution": "  }", "suffix": "  return max_index;", "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"}
{"task_id": "HumanEval_136_largest_smallest_integers", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as None.\n// Examples:\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    // Your code here\n    std::vector<long> positive;\n    std::vector<long> negative;\n    for(long val : lst){\n        if(val > 0){\n            positive.push_back(val);", "canonical_solution": "        }else if(val < 0){", "suffix": "            negative.push_back(val);\n        }\n    }\n    std::optional<long> max_neg = std::nullopt;\n    std::optional<long> min_pos = std::nullopt;\n    if(positive.size() > 0){\n        std::sort(positive.begin(), positive.end());\n        min_pos = positive[0];\n    }\n    if(negative.size() > 0){\n        std::sort(negative.begin(), negative.end());\n        max_neg = negative[negative.size() - 1];\n    }\n    return std::make_tuple(max_neg, min_pos);", "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"}
{"task_id": "HumanEval_138_is_equal_to_sum_even", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\nbool is_equal_to_sum_even(long n) {", "canonical_solution": "    return n % 2 == 0 && n / 2 > 3;", "suffix": "", "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"}
{"task_id": "HumanEval_139_special_factorial", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long result = 1;\n  while (n > 0) {\n    long i = n;\n    while (i > 0) {\n      result *= i;\n      i--;\n    }\n    n--;", "canonical_solution": "  }", "suffix": "  return result;", "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"}
{"task_id": "HumanEval_13_greatest_common_divisor", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\nlong greatest_common_divisor(long a, long b) {\n    while (a != b) {\n        if (a > b)\n            a = a - b;", "canonical_solution": "        else", "suffix": "            b = b - a;\n    }\n    return a;", "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"}
{"task_id": "HumanEval_140_fix_spaces", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with -\nstd::string fix_spaces(std::string text) {\n  int spaces = 0;\n  for (int i = 0; i < text.length(); i++) {\n    if (text[i] == ' ') {\n      spaces++;\n    }\n  }\n  std::string new_text;\n  if (spaces <= 2) {\n    for (int i = 0; i < text.length(); i++) {\n      if (text[i] == ' ') {\n        new_text += '_';\n      } else {\n        new_text += text[i];\n      }\n    }\n  } else {\n    int spaces = 0;\n    for (int i = 0; i < text.length(); i++) {\n      if (text[i] == ' ') {\n        spaces++;\n      } else {\n        if (spaces > 2) {\n          new_text += '-';\n          spaces = 0;\n        } else if (spaces > 0) {\n          for (int j = 0; j < spaces; j++) {\n            new_text += '_';\n          }", "canonical_solution": "          spaces = 0;", "suffix": "        }\n        new_text += text[i];\n      }\n    }\n  }\n  return new_text;", "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"}
{"task_id": "HumanEval_141_file_name_check", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\nstd::string file_name_check(std::string file_name) {\n    if (file_name.find('.') == std::string::npos) {\n        return \"No\";\n    }\n    std::string extension = file_name.substr(file_name.find('.') + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n    std::string file_name_without_extension = file_name.substr(0, file_name.find('.'));\n    if (file_name_without_extension.length() == 0) {\n        return \"No\";\n    }\n    int count = 0;\n    for (int i = 0; i < file_name_without_extension.length(); i++) {", "canonical_solution": "        if (isdigit(file_name_without_extension[i])) {", "suffix": "            count++;\n        }\n    }\n    if (count > 3) {\n        return \"No\";\n    }\n    if (!isalpha(file_name_without_extension[0])) {\n        return \"No\";\n    }\n    return \"Yes\";", "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"}
{"task_id": "HumanEval_142_sum_squares", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\nlong sum_squares(std::vector<long> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += pow(lst[i], 2);\n        }", "canonical_solution": "        else if (i % 4 == 0 && i % 3 != 0) {", "suffix": "            sum += pow(lst[i], 3);\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    return sum;", "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"}
{"task_id": "HumanEval_143_words_in_sentence", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// Example 2:\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> v;\n    while (ss >> word) {\n        v.push_back(word);\n    }\n    auto IsPrime = [](int n) {\n        if (n < 2) {\n            return false;\n        }\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    for (int i = 0; i < v.size(); i++) {\n        if (!IsPrime(v[i].size())) {\n            v.erase(v.begin() + i);\n            i--;\n        }\n    }\n    std::string res;\n    for (int i = 0; i < v.size(); i++) {", "canonical_solution": "        res += v[i];", "suffix": "        if (i < v.size() - 1) {\n            res += \" \";\n        }\n    }\n    return res;", "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"}
{"task_id": "HumanEval_144_simplify", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns True if x * n evaluates to a whole number and False\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\nbool simplify(std::string x, std::string n) {\n    long x_num = std::stol(x.substr(0, x.find('/')));\n    long x_den = std::stol(x.substr(x.find('/') + 1));\n    long n_num = std::stol(n.substr(0, n.find('/')));\n    long n_den = std::stol(n.substr(n.find('/') + 1));\n    if (x_num * n_den * n_num * x_den == 0) return false;\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n    for (long i = 2; i <= std::min(num, den); i++) {\n        while (num % i == 0 && den % i == 0) {\n            num /= i;", "canonical_solution": "            den /= i;", "suffix": "        }\n    }\n    return num % den == 0;", "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"}
{"task_id": "HumanEval_146_specialFilter", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an array of numbers as input and returns \n// the number of elements in the array that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for(long i = 0; i < nums.size(); i++) {\n        if(nums[i] > 10 && std::to_string(nums[i]).front() % 2 != 0 && std::to_string(nums[i]).back() % 2 != 0) {\n            count++;\n        }\n    }", "canonical_solution": "    return count;", "suffix": "", "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"}
{"task_id": "HumanEval_147_get_max_triples", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long sum = 0;\n    for(long i = 1; i <= n; i++)\n    {\n        for(long j = i+1; j <= n; j++)\n        {\n            for(long k = j+1; k <= n; k++)\n            {\n                if((i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0)\n                {\n                    sum++;\n                }\n            }", "canonical_solution": "        }", "suffix": "    }\n    return sum;", "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"}
{"task_id": "HumanEval_148_bf", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> solarsystem = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> res;\n  if (std::find(solarsystem.begin(), solarsystem.end(), planet1) == solarsystem.end() || std::find(solarsystem.begin(), solarsystem.end(), planet2) == solarsystem.end()) {\n    return res;\n  }\n  int planet1Idx = std::find(solarsystem.begin(), solarsystem.end(), planet1) - solarsystem.begin();", "canonical_solution": "  int planet2Idx = std::find(solarsystem.begin(), solarsystem.end(), planet2) - solarsystem.begin();", "suffix": "  if (planet1Idx > planet2Idx) {\n    std::swap(planet1Idx, planet2Idx);\n  }\n  for (int i = planet1Idx + 1; i < planet2Idx; i++) {\n    res.push_back(solarsystem[i]);\n  }\n  return res;", "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"}
{"task_id": "HumanEval_149_sorted_list_sum", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> res;\n    for (auto el : lst) {\n        if (el.size() % 2 == 0) {\n            res.push_back(el);\n        }\n    }\n    std::sort(res.begin(), res.end(), [](std::string a, std::string b) {", "canonical_solution": "        if (a.size() == b.size()) {", "suffix": "            return a < b;\n        }\n        return a.size() < b.size();\n    });\n    return res;", "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"}
{"task_id": "HumanEval_14_all_prefixes", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list of all prefixes from shortest to longest of the input string\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> ret;\n    for (int len = 1; len <= string.size(); len++) {\n        ret.push_back(string.substr(0, len));\n    }", "canonical_solution": "    return ret;", "suffix": "", "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"}
{"task_id": "HumanEval_150_x_or_y", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\nlong x_or_y(long n, long x, long y) {\n    if(n<2)\n        return y;", "canonical_solution": "    for(long i=2;i<=sqrt(n);i++)", "suffix": "        if(n%i==0)\n            return y;\n    return x;", "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"}
{"task_id": "HumanEval_151_double_the_difference", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// If the input list is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    if(lst.size()==0) {\n        return 0;\n    }\n    for(auto i: lst) {\n        if(i>0 && (long)i%2==1) {\n            sum += (long)i*(long)i;\n        }", "canonical_solution": "    }", "suffix": "    return sum;", "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"}
{"task_id": "HumanEval_152_compare", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match. \n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {", "canonical_solution": "    if (game[i] == guess[i]) {", "suffix": "      result.push_back(0);\n    } else {\n      long m = std::abs(game[i] - guess[i]);\n      result.push_back(m);\n    }\n  }\n  return result;", "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"}
{"task_id": "HumanEval_153_Strongest_Extension", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n\tstd::vector<std::string> strength;\n\tint count=0;\n\tfor(int i=0;i<extensions.size();i++)\n\t{\n\t\tint up=0,low=0;\n\t\tfor(int j=0;j<extensions[i].size();j++)\n\t\t{\n\t\t\tif(extensions[i][j]>='A' && extensions[i][j]<='Z')\n\t\t\t\tup++;\n\t\t\telse if(extensions[i][j]>='a' && extensions[i][j]<='z')\n\t\t\t\tlow++;\n\t\t}\n\t\tint temp = up-low;\n\t\tstrength.push_back(std::to_string(temp));\n\t}\n\tfor(int i=0;i<strength.size();i++)\n\t{\n\t\tstd::cout<<strength[i]<<\" \";\n\t}\n\tstd::cout<<std::endl;\n\tint max=INT_MIN;\n\tfor(int i=0;i<strength.size();i++)\n\t{\n\t\tint a = std::stoi(strength[i]);\n\t\tif(a>max)\n\t\t{\n\t\t\tmax=a;\n\t\t\tcount=i;\n\t\t}\n\t}\n\tstd::cout<<\"count is: \"<<count<<std::endl;\n\tstd::string s = class_name+\".\"+extensions[count];", "canonical_solution": "\treturn s;", "suffix": "", "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"}
{"task_id": "HumanEval_154_cycpattern_check", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\nbool cycpattern_check(std::string a, std::string b) {\n  // Write your code here\n  if(a.length()<b.length())\n    return false;\n  if(a.length()==b.length() && a!=b)\n    return false;\n  if(a.length()==b.length() && a==b)\n    return true;\n  int p=a.find(b);\n  if(p!=std::string::npos)\n    return true;\n  int i;\n  for(i=0;i<b.length();i++)\n  {\n    char temp=b[0];\n    int j;\n    for(j=0;j<b.length()-1;j++)\n    {\n      b[j]=b[j+1];", "canonical_solution": "    }", "suffix": "    b[j]=temp;\n    if(a.find(b)!=std::string::npos)\n      return true;\n  }\n  return false;", "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"}
{"task_id": "HumanEval_155_even_odd_count", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\nstd::tuple<long, long> even_odd_count(long num) {\n    int even = 0, odd = 0;\n    if(num == 0) {\n        even++;\n    }", "canonical_solution": "    else {", "suffix": "        while(num != 0) {\n            if(num % 2 == 0) {\n                even++;\n            }\n            else {\n                odd++;\n            }\n            num /= 10;\n        }\n    }\n    return std::make_tuple(even, odd);", "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"}
{"task_id": "HumanEval_156_int_to_mini_roman", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\nstd::string int_to_mini_roman(long number) {\n    int num[] = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n    std::string sym[] = {\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"};\n    int i = 12;\n    std::string roman;\n    while (number > 0) {\n        int div = number / num[i];", "canonical_solution": "        number = number % num[i];", "suffix": "        while (div--) {\n            roman += sym[i];\n        }\n        i--;\n    }\n    return roman;", "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"}
{"task_id": "HumanEval_157_right_angle_triangle", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return True if the three\n// sides form a right-angled triangle, False otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long* tri = new long[3];\n    tri[0] = a;\n    tri[1] = b;\n    tri[2] = c;\n    std::sort(tri, tri+3);\n    long a2 = tri[0]*tri[0];", "canonical_solution": "    long b2 = tri[1]*tri[1];", "suffix": "    long c2 = tri[2]*tri[2];\n    bool result = false;\n    if (a2+b2 == c2) {\n        result = true;\n    }\n    return result;", "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"}
{"task_id": "HumanEval_158_find_max", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\nstd::string find_max(std::vector<std::string> words) {\n    if (words.size() == 0) {\n        return \"\";\n    }\n\n    std::unordered_map<char, int> freq;\n    int max_count = 0;\n    std::string answer = \"\";\n    for (std::string word : words) {\n        freq.clear();\n        for (char c : word) {", "canonical_solution": "            freq[c]++;", "suffix": "        }\n        int total_characters = freq.size();\n        if (total_characters > max_count) {\n            max_count = total_characters;\n            answer = word;\n        } else if (total_characters == max_count) {\n            if (word < answer) {\n                answer = word;\n            }\n        }\n    }\n    return answer;", "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"}
{"task_id": "HumanEval_159_eat", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return an array of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    std::vector<long> a;\n    if (remaining < need) {\n        a.push_back(number + remaining);", "canonical_solution": "        a.push_back(0);", "suffix": "    } else {\n        a.push_back(number + need);\n        a.push_back(remaining - need);\n    }\n    return a;", "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"}
{"task_id": "HumanEval_15_string_sequence", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nstd::string string_sequence(long n) {\n  // your code goes here\n  std::string s;", "canonical_solution": "  for(int i=0;i<=n;i++)", "suffix": "  {\n    std::string s1=std::to_string(i);\n    s=s+s1+\" \";\n  }\n  s.pop_back();\n  return s;", "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"}
{"task_id": "HumanEval_161_solve", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\nstd::string solve(std::string s) {\n  std::string res = \"\";\n  for (char &c : s) {\n    if (islower(c)) {\n      res += toupper(c);\n    } else if (isupper(c)) {\n      res += tolower(c);\n    } else {\n      res += c;\n    }\n  }", "canonical_solution": "  if (res.find_first_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") == std::string::npos) {", "suffix": "    std::reverse(res.begin(), res.end());\n  }\n  return res;", "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"}
{"task_id": "HumanEval_16_count_distinct_characters", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\nlong count_distinct_characters(std::string string) {\n\tstd::transform(string.begin(), string.end(), string.begin(), ::tolower);\n\tstd::unordered_set<char> distinctCharSet;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tdistinctCharSet.insert(string[i]);", "canonical_solution": "\t}", "suffix": "\treturn distinctCharSet.size();", "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"}
{"task_id": "HumanEval_17_parse_music", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> result;\n  std::stringstream ss(music_string);\n  std::string item;\n  while (std::getline(ss, item, ' ')) {\n    if (item == \"o\") {\n      result.push_back(4);\n    } else if (item == \"o|\") {\n      result.push_back(2);\n    } else if (item == \".|\") {\n      result.push_back(1);", "canonical_solution": "    }", "suffix": "  }\n  return result;", "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"}
{"task_id": "HumanEval_18_how_many_times", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\nlong how_many_times(std::string string, std::string substring) {\n    int pos = string.find(substring);\n    long count = 0;", "canonical_solution": "    while (pos!=std::string::npos) {", "suffix": "        ++count;\n        pos = string.find(substring, pos+1);\n    }\n    return count;", "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"}
{"task_id": "HumanEval_19_sort_numbers", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\nstd::string sort_numbers(std::string numbers) {\n    std::map<std::string, int> num = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    std::stringstream ss(numbers);\n    std::vector<int> vec;\n    std::string str;\n    while(ss >> str) {\n        vec.push_back(num[str]);\n    }\n    std::sort(vec.begin(), vec.end());\n    std::stringstream s;\n    for(int i = 0; i < vec.size(); i++) {\n        for(auto it = num.begin(); it != num.end(); it++) {\n            if(it->second == vec[i]) {\n                s << it->first << \" \";\n            }\n        }", "canonical_solution": "    }", "suffix": "    std::string a = s.str();\n    return a.substr(0, a.size() - 1);", "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"}
{"task_id": "HumanEval_1_separate_paren_groups", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> output;\n    // We use a stack to keep track of the current balanced paren group\n    std::stack<char> paren_stack;\n    std::string curr_paren_string;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            paren_stack.push(*it);\n            curr_paren_string.push_back(*it);\n        } else if (*it == ')') {\n            if (paren_stack.empty()) {\n                // Missmatched braces. Can't proceed.\n                return output;\n            }\n            paren_stack.pop();\n            curr_paren_string.push_back(*it);\n            if (paren_stack.empty()) {\n                // We completed a balanced paren string. Add it to output and reset.\n                output.push_back(curr_paren_string);\n                curr_paren_string.clear();", "canonical_solution": "            }", "suffix": "        }\n    }\n    return output;", "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"}
{"task_id": "HumanEval_21_rescale_to_unit", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  std::vector<float> out;\n  // insert your code here\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n  float temp;\n  for(int i=0; i<numbers.size(); i++){", "canonical_solution": "    temp = (numbers[i]-min)/(max-min);", "suffix": "    out.push_back(temp);\n  }\n  return out;", "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"}
{"task_id": "HumanEval_22_filter_integers", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given list of any python values only for integers\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> ret;\n    for (auto val : values) {\n        if (val.type() == typeid(int)) {\n            ret.push_back(std::any_cast<int>(val));\n        } else if (val.type() == typeid(long)) {\n            ret.push_back(std::any_cast<long>(val));\n        }\n    }", "canonical_solution": "    return ret;", "suffix": "", "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"}
{"task_id": "HumanEval_23_strlen", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\nlong string_length(std::string string) {", "canonical_solution": "    return string.length();", "suffix": "", "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"}
{"task_id": "HumanEval_24_largest_divisor", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\nlong largest_divisor(long n) {\n    for (long i = n-1; i >= 1; i--) {\n        if (n % i == 0)", "canonical_solution": "            return i;", "suffix": "    }\n    return 1;", "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"}
{"task_id": "HumanEval_25_factorize", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\nstd::vector<long> factorize(long n) {\n    assert(n >= 1);\n    std::vector<long> factorization;\n    long current_divisor = 2;\n    while (n > 1) {\n        while (n % current_divisor == 0) {\n            factorization.push_back(current_divisor);\n            n /= current_divisor;\n        }\n        current_divisor++;\n    }", "canonical_solution": "    return factorization;", "suffix": "", "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"}
{"task_id": "HumanEval_26_remove_duplicates", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> output;\n    std::map<long, int> occurences;\n    for (std::vector<long>::iterator it = numbers.begin(); it != numbers.end(); ++it) {", "canonical_solution": "        occurences[*it]++;", "suffix": "    }\n    for (std::vector<long>::iterator it = numbers.begin(); it != numbers.end(); ++it) {\n        if (occurences[*it] == 1) {\n            output.push_back(*it);\n        }\n    }\n    return output;", "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"}
{"task_id": "HumanEval_27_flip_case", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\nstd::string flip_case(std::string string) {\n\t// write your code here\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] >= 'a' && string[i] <= 'z') {\n\t\t\tstring[i] = string[i] - 32;\n\t\t}\n\t\telse if (string[i] >= 'A' && string[i] <= 'Z') {", "canonical_solution": "\t\t\tstring[i] = string[i] + 32;", "suffix": "\t\t}\n\t}\n\treturn string;", "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"}
{"task_id": "HumanEval_28_concatenate", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate list of strings into a single string\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (auto& s : strings) {", "canonical_solution": "    result += s;", "suffix": "  }\n  return result;", "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"}
{"task_id": "HumanEval_29_filter_by_prefix", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of strings only for ones that start with a given prefix.\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    std::copy_if(strings.begin(), strings.end(), std::back_inserter(result), [&prefix](std::string s) {\n        return s.rfind(prefix, 0) == 0;", "canonical_solution": "    });", "suffix": "    return result;", "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"}
{"task_id": "HumanEval_2_truncate_number", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;", "canonical_solution": "    return decimal_part;", "suffix": "", "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"}
{"task_id": "HumanEval_30_get_positive", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the list.\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (auto i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }", "canonical_solution": "    return result;", "suffix": "", "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"}
{"task_id": "HumanEval_31_is_prime", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (long i = 2; i < n; i++) {\n        if (n % i == 0) {", "canonical_solution": "            return false;", "suffix": "        }\n    }\n    return true;", "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"}
{"task_id": "HumanEval_33_sort_third", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\nstd::vector<long> sort_third(std::vector<long> l) {\n\tstd::vector<long> a;\n\tstd::vector<long> b;\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tif (i % 3 == 0) {\n\t\t\ta.push_back(l[i]);\n\t\t}\n\t\telse {\n\t\t\tb.push_back(l[i]);\n\t\t}\n\t}", "canonical_solution": "\tstd::sort(a.begin(), a.end());", "suffix": "\tfor (int i = 0; i < a.size(); i++) {\n\t\tb.insert(b.begin() + 3 * i, a[i]);\n\t}\n\treturn b;", "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"}
{"task_id": "HumanEval_34_unique", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a list\nstd::vector<long> unique(std::vector<long> l) {\n    std::vector<long> sorted = l;\n    std::sort(sorted.begin(), sorted.end());\n    std::vector<long> result;\n    for (auto a : sorted) {", "canonical_solution": "        if (result.size() == 0) {", "suffix": "            result.push_back(a);\n        } else if (result[result.size() - 1] != a) {\n            result.push_back(a);\n        }\n    }\n    return result;", "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"}
{"task_id": "HumanEval_35_max_element", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the list.\nlong max_element(std::vector<long> l) {", "canonical_solution": "    return *std::max_element(l.begin(), l.end());", "suffix": "", "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"}
{"task_id": "HumanEval_36_fizz_buzz", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\nlong fizz_buzz(long n) {\n    long seven_count=0;\n    for(long i=1;i<n;i++){\n        if(i%11==0||i%13==0){\n            int copy_i=i;\n            while(copy_i>0){\n                if(copy_i%10==7){\n                    seven_count++;\n                }\n                copy_i/=10;\n            }", "canonical_solution": "        }", "suffix": "    }\n    return seven_count;", "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"}
{"task_id": "HumanEval_37_sort_even", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\nstd::vector<long> sort_even(std::vector<long> l) {\n    for (int i = 0; i < l.size(); i+=2) {\n        for (int j = 0; j < l.size() - 1; j+=2) {\n            if (l[j] > l[j+2]) {\n                long temp = l[j];\n                l[j] = l[j+2];", "canonical_solution": "                l[j+2] = temp;", "suffix": "            }\n        }\n    }\n    return l;", "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"}
{"task_id": "HumanEval_39_prime_fib", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nlong prime_fib(long n) {\n   if (n == 1) return 2;\n   if (n == 2) return 3;\n   if (n == 3) return 5;\n   if (n == 4) return 13;", "canonical_solution": "   if (n == 5) return 89;", "suffix": "   if (n == 6) return 233;\n   if (n == 7) return 1597;\n   if (n == 8) return 28657;\n   if (n == 9) return 514229;\n   if (n == 10) return 433494437;\n   if (n == 11) return 2971215073;\n   if (n == 12) return 99194853094755497;\n   assert(false);", "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"}
{"task_id": "HumanEval_3_below_zero", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return True. Otherwise it should return False.\nbool below_zero(std::vector<long> operations) {\n\tint sum = 0;\n\tfor (int i = 0; i < operations.size(); i++) {", "canonical_solution": "\t\tsum += operations[i];", "suffix": "\t\tif (sum < 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;", "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"}
{"task_id": "HumanEval_40_triples_sum_to_zero", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a list of integers as an input.\n// it returns True if there are three distinct elements in the list that\n// sum to zero, and False otherwise.\nbool triples_sum_to_zero(std::vector<long> l) {\n    for (long i = 0; i < l.size(); i++) {\n        for (long j = i + 1; j < l.size(); j++) {\n            for (long k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }", "canonical_solution": "            }", "suffix": "        }\n    }\n    return false;", "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"}
{"task_id": "HumanEval_42_incr_list", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list with elements incremented by 1.\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> res;\n    int i = 0;\n    while (i < l.size()) {\n        res.push_back(l[i] + 1);\n        i = i + 1;\n    }", "canonical_solution": "    return res;", "suffix": "", "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"}
{"task_id": "HumanEval_43_pairs_sum_to_zero", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a list of integers as an input.\n// it returns True if there are two distinct elements in the list that\n// sum to zero, and False otherwise.\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int len = l.size();\n    for (int i = 0; i < len; i++) {", "canonical_solution": "        for (int j = i + 1; j < len; j++) {", "suffix": "            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;", "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"}
{"task_id": "HumanEval_44_change_base", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\nstd::string change_base(long x, long base) {\n\tstd::string s = \"\";\n\twhile (x != 0) {\n\t\ts = std::to_string(x % base) + s;\n\t\tx /= base;\n\t}", "canonical_solution": "\treturn s;", "suffix": "", "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"}
{"task_id": "HumanEval_45_triangle_area", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\nfloat triangle_area(long a, long h) {", "canonical_solution": "    // Write your code here", "suffix": "    return (a*h*0.5);", "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"}
{"task_id": "HumanEval_46_fib4", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\nlong fib4(long n) {\n  std::vector<long> v(4);\n  v[0] = 0;\n  v[1] = 0;\n  v[2] = 2;\n  v[3] = 0;\n  if (n == 0) return v[0];\n  if (n == 1) return v[1];\n  if (n == 2) return v[2];\n  if (n == 3) return v[3];\n  std::vector<long> c(4);\n  for (int i = 4; i <= n; i++) {\n    c[0] = v[1];\n    c[1] = v[2];\n    c[2] = v[3];", "canonical_solution": "    c[3] = v[0] + v[1] + v[2] + v[3];", "suffix": "    v = c;\n  }\n  return v[3];", "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"}
{"task_id": "HumanEval_47_median", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the list l.\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int index = floor(l.size() / 2);\n    if (l.size() % 2 == 0) {\n        return float(l[index - 1] + l[index]) / 2;\n    } else {", "canonical_solution": "        return float(l[index]);", "suffix": "    }", "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"}
{"task_id": "HumanEval_48_is_palindrome", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\nbool is_palindrome(std::string text) {\n\t// YOUR CODE GOES HERE\n\tfor (int i = 0; i < text.length() / 2; i++) {\n\t\tif (text[i] != text[text.length() - 1 - i]) {\n\t\t\treturn false;\n\t\t}", "canonical_solution": "\t}", "suffix": "\treturn true;", "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"}
{"task_id": "HumanEval_49_modp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p > 0);\n\t", "canonical_solution": "\t// (n * (2^n mod p)) mod p", "suffix": "\t// = ((n mod p) * (2^n mod p)) mod p\n\t// = ((n mod p) * (2^(n mod (p-1)) mod p)) mod p\n\t\n\tlong result = 1;\n\tlong two = 2;\n\twhile (n > 0) {\n\t\t// compute the square modulo p\n\t\tif (n % 2 != 0) {\n\t\t\tresult = (result * two) % p;\n\t\t}\n\t\tn /= 2;\n\t\ttwo = (two * two) % p;\n\t}\n\treturn result;", "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"}
{"task_id": "HumanEval_51_remove_vowels", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\nstd::string remove_vowels(std::string text) {\n\t\t\n\t\tstd::string str;\n\t\tstd::string str1;\n\t\tint n=text.length();\n\t\tfor(int i=0;i<n;i++)\n\t\t{", "canonical_solution": "\t\t\t", "suffix": "\t\t\tif(text[i]!='a'&&text[i]!='e'&&text[i]!='i'&&text[i]!='o'&&text[i]!='u'&&text[i]!='A'&&text[i]!='E'&&text[i]!='I'&&text[i]!='O'&&text[i]!='U')\n\t\t\t{\n\t\t\t\tstr+=text[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;", "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"}
{"task_id": "HumanEval_52_below_threshold", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return True if all numbers in the list l are below threshold t.\nbool below_threshold(std::vector<long> l, long t) {", "canonical_solution": "    return std::all_of(l.begin(), l.end(), [t](long x) { return x < t; });", "suffix": "", "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"}
{"task_id": "HumanEval_53_add", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\nlong add(long x, long y) {\n    if (y == 0) {\n        return x;\n    }", "canonical_solution": "    return add(x ^ y, (x & y) << 1);", "suffix": "", "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"}
{"task_id": "HumanEval_54_same_chars", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\nbool same_chars(std::string s0, std::string s1) {\n  int length0 = s0.length();\n  int length1 = s1.length();\n  std::vector<char> vector0(length0);\n  std::vector<char> vector1(length1);\n  std::vector<int> vector2(length0);\n  std::vector<int> vector3(length1);\n  for (int i = 0; i < length0; i++) {\n    vector0[i] = s0[i];\n  }\n  for (int i = 0; i < length1; i++) {\n    vector1[i] = s1[i];\n  }\n  for (int i = 0; i < length0; i++) {\n    for (int j = 0; j < length1; j++) {\n      if (vector0[i] == vector1[j]) {\n        vector2[i] = 1;\n        vector3[j] = 1;\n      }\n    }\n  }\n  int count0 = 0;\n  int count1 = 0;\n  for (int i = 0; i < length0; i++) {\n    if (vector2[i] == 1) {\n      count0++;\n    }\n  }\n  for (int i = 0; i < length1; i++) {\n    if (vector3[i] == 1) {\n      count1++;\n    }", "canonical_solution": "  }", "suffix": "  if (count0 == length0 && count1 == length1) {\n    return true;\n  }\n  return false;", "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"}
{"task_id": "HumanEval_55_fib", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\nlong fib(long n) {\n\tstd::vector<long> fib(n + 1);\n\tfib[0] = 0;\n\tfib[1] = 1;\n\tfor (long i = 2; i <= n; i++) {", "canonical_solution": "\t\tfib[i] = fib[i - 1] + fib[i - 2];", "suffix": "\t}\n\treturn fib[n];", "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"}
{"task_id": "HumanEval_56_correct_bracketing", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return True if every opening bracket has a corresponding closing bracket.\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (int i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '<') {\n            s.push(brackets[i]);", "canonical_solution": "        } else {", "suffix": "            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();", "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"}
{"task_id": "HumanEval_57_monotonic", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return True is list elements are monotonically increasing or decreasing.\nbool monotonic(std::vector<long> l) {\n    if (l.size()<=1) {\n        return true;\n    }\n    auto first_diff = l[1] - l[0];\n    auto increasing = first_diff >= 0;\n    if (increasing) {\n        for (int i=1; i<l.size()-1; i++) {\n            if (l[i+1] < l[i]) {\n                return false;\n            }\n        }\n    } else {\n        for (int i=1; i<l.size()-1; i++) {\n            if (l[i+1] > l[i]) {\n                return false;", "canonical_solution": "            }", "suffix": "        }\n    }\n    return true;", "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"}
{"task_id": "HumanEval_58_common", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two lists.\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n   std::vector<long> commonElements;\n   std::sort(l1.begin(), l1.end());\n   std::sort(l2.begin(), l2.end());", "canonical_solution": "   std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),", "suffix": "      std::back_inserter(commonElements));\n   return commonElements;", "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"}
{"task_id": "HumanEval_59_largest_prime_factor", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\nlong largest_prime_factor(long n) {\n    std::vector<long> factors;\n    // TODO: write code here to compute factors\n    long copy_n = n;\n    while(copy_n % 2 == 0){\n        factors.push_back(2);\n        copy_n /= 2;\n    }\n    for(long i = 3; i < sqrt(copy_n); i+=2){", "canonical_solution": "        while(copy_n % i == 0){", "suffix": "            factors.push_back(i);\n            copy_n /= i;\n        }\n    }\n    if(copy_n > 2){\n        factors.push_back(copy_n);\n    }\n    // Factors will contain all the prime factors of n\n    // The last element of the vector is the largest prime factor.\n    return factors.back();", "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"}
{"task_id": "HumanEval_5_intersperse", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    assert(delimeter >= 0);\n    if (numbers.size() == 0) return numbers;\n    std::vector<long> output;\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        output.push_back(numbers[i]);\n        output.push_back(delimeter);", "canonical_solution": "    }", "suffix": "    output.push_back(numbers[numbers.size() - 1]);\n    return output;", "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"}
{"task_id": "HumanEval_60_sum_to_n", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\nlong sum_to_n(long n) {", "canonical_solution": "\treturn n*(n+1)/2;", "suffix": "", "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"}
{"task_id": "HumanEval_61_correct_bracketing", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nbool correct_bracketing(std::string brackets) {\n\tstd::stack<char> st;\n\tfor (int i = 0; i < brackets.size(); i++) {\n\t\tif (brackets[i] == '(') {\n\t\t\tst.push(brackets[i]);\n\t\t}\n\t\telse if (brackets[i] == ')') {\n\t\t\tif (st.empty()) return false;\n\t\t\telse st.pop();\n\t\t}\n\t}\n\tif (st.empty()) return true;", "canonical_solution": "\telse return false;", "suffix": "", "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"}
{"task_id": "HumanEval_62_derivative", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> coeff;\n  for (int i = 1; i < xs.size(); i++) {\n    coeff.push_back(xs[i] * i);", "canonical_solution": "  }", "suffix": "  return coeff;", "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"}
{"task_id": "HumanEval_63_fibfib", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\nlong fibfib(long n) {\n    long a[n+1];\n    if(n == 0)\n        return 0;\n    else if(n == 1)\n        return 0;\n    else if(n == 2)\n        return 1;\n    else{\n        a[0] = 0;\n        a[1] = 0;\n        a[2] = 1;\n        for(int i = 3; i <= n; i++){", "canonical_solution": "            a[i] = a[i-1] + a[i-2] + a[i-3];", "suffix": "        }\n        return a[n];\n    }", "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"}
{"task_id": "HumanEval_64_vowels_count", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\nlong vowels_count(std::string s) {\n    int count = 0;\n    std::string vowels = \"aeiouy\";\n    std::string input = s;\n    std::transform(input.begin(), input.end(), input.begin(), ::tolower);\n    std::cout << input << '\\n';\n    for (auto const &vowel : vowels) {\n        std::size_t found = input.find(vowel);\n        while (found != std::string::npos) {\n            if (vowel == 'y' && found != input.length() - 1) {\n                found = input.find(vowel, found + 1);\n                continue;", "canonical_solution": "            }", "suffix": "            count++;\n            found = input.find(vowel, found + 1);\n        }\n    }\n    return count;", "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"}
{"task_id": "HumanEval_65_circular_shift", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\nstd::string circular_shift(long x, long shift) {\n    std::string x_str = std::to_string(x);\n    if (shift > x_str.size()) {", "canonical_solution": "        std::reverse(x_str.begin(), x_str.end());", "suffix": "        return x_str;\n    }\n    std::rotate(x_str.begin(), x_str.begin() + x_str.size() - shift, x_str.end());\n    return x_str;", "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"}
{"task_id": "HumanEval_66_digitSum", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\nlong digitSum(std::string s) {\n  //lowercase\n  int sum = 0;", "canonical_solution": "  for(char c : s){", "suffix": "    if(isupper(c)){\n      sum += (int)c;\n    }\n  }\n  return sum;", "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"}
{"task_id": "HumanEval_67_fruit_distribution", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\nlong fruit_distribution(std::string s, long n) {\n\tlong A, O;\n\tint pos = s.find(\" and \");\n\tA = std::stol(s.substr(0, pos));\n\tO = std::stol(s.substr(pos + 5));", "canonical_solution": "\treturn n - A - O;", "suffix": "", "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"}
{"task_id": "HumanEval_68_pluck", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// Example 1:\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n\tif (arr.size() == 0) {\n\t\treturn {};\n\t}\n\tint min = 10000;\n\tint min_idx = -1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\tif (arr[i] < min) {", "canonical_solution": "\t\t\t\tmin = arr[i];", "suffix": "\t\t\t\tmin_idx = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (min_idx == -1) {\n\t\treturn {};\n\t}\n\treturn { (long)min, (long)min_idx };", "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"}
{"task_id": "HumanEval_69_search", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long> lst) {\n    long max_freq = -1;\n    std::map<long, long> freq;\n    for (long i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n        if (freq[lst[i]] >= lst[i])\n            max_freq = std::max(max_freq, lst[i]);\n    }", "canonical_solution": "    return max_freq;", "suffix": "", "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"}
{"task_id": "HumanEval_6_parse_nested_parens", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    int count = 0;\n    int final = 0;\n    int level = 0;\n    std::vector<long> result;\n    for (int i = 0; i < paren_string.length(); i++) {\n        if (paren_string[i] == '(') {\n            count++;\n            if (count > final)\n                final = count;\n        }\n        else if (paren_string[i] == ')') {\n            count--;\n        }\n        else if (paren_string[i] == ' ') {\n            level = final;\n            result.push_back(level);\n            final = 0;\n            count = 0;\n        }\n    }", "canonical_solution": "    level = final;", "suffix": "    result.push_back(level);\n    return result;", "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"}
{"task_id": "HumanEval_70_strange_sort_list", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    // your code here\n    std::vector<long> temp = lst;\n    std::sort(temp.begin(), temp.end());\n    std::vector<long>temp1;\n    if(temp.size()%2==0){\n        int  i=0;\n        int j=temp.size()-1;\n        for(int k=0;k<temp.size();k++)\n        {\n            if(k%2==0)\n            {\n                temp1.push_back(temp[i]);\n                i++;\n            }\n            else\n            {\n                temp1.push_back(temp[j]);", "canonical_solution": "                j--;", "suffix": "            }\n        }\n        return temp1;\n    }\n    else{\n        int i=0;\n        int j=temp.size()-1;\n        for(int k=0;k<temp.size();k++)\n        {\n            if(k%2==0)\n            {\n                temp1.push_back(temp[i]);\n                i++;\n            }\n            else\n            {\n                temp1.push_back(temp[j]);\n                j--;\n            }\n        }\n        return temp1;\n    }", "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"}
{"task_id": "HumanEval_72_will_it_fly", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns True if the object q will fly, and False otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    int j = q.size() - 1;\n    for (int i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[j]) {\n            return false;\n        }\n        j--;\n    }\n    int sum = 0;\n    for (auto it = q.begin(); it != q.end(); it++) {\n        sum += *it;\n    }", "canonical_solution": "    if (sum <= w) {", "suffix": "        return true;\n    }\n    return false;", "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"}
{"task_id": "HumanEval_73_smallest_change", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\nlong smallest_change(std::vector<long> arr) {\n  int i,j, count=0;\n  for(i=0,j=arr.size()-1;i<j;i++,j--){\n    if(arr[i]!=arr[j]){", "canonical_solution": "      count++;", "suffix": "    }\n  }\n  return count;", "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"}
{"task_id": "HumanEval_74_total_match", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two lists of strings and returns the list that has \n// total number of chars in the all strings of the list less than the other list.\n// if the two lists have the same number of chars, return the first list.\n// Examples\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  if(lst1.size() == 0)\n  {\n    return lst1;\n  }\n  if(lst2.size() == 0)\n  {\n    return lst2;\n  }\n  int count1 = 0;\n  int count2 = 0;\n  for(int i = 0; i < lst1.size(); i++)\n  {\n    count1 += lst1[i].size();\n  }\n  for(int i = 0; i < lst2.size(); i++)\n  {", "canonical_solution": "    count2 += lst2[i].size();", "suffix": "  }\n  if(count1 == count2)\n  {\n    return lst1;\n  }\n  else if(count1 < count2)\n  {\n    return lst1;\n  }\n  else\n  {\n    return lst2;\n  }", "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"}
{"task_id": "HumanEval_75_is_multiply_prime", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    int n = a;\n    std::vector<int> prime_numbers;\n    prime_numbers.push_back(2);\n    while (n != 1) {\n        if (n % prime_numbers.back() == 0) {\n            prime_numbers.push_back(prime_numbers.back());\n            n /= prime_numbers.back();\n        } else {\n            prime_numbers.back()++;\n        }\n    }\n    std::cout << std::endl;\n    int num = prime_numbers.size();\n    for (int i = 0; i < num - 3; i++) {\n        for (int j = i + 1; j < num - 2; j++) {\n            for (int k = j + 1; k < num - 1; k++) {\n                if (prime_numbers[i] * prime_numbers[j] * prime_numbers[k] == a) {\n                    return true;\n                }\n            }", "canonical_solution": "        }", "suffix": "    }\n    return false;", "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"}
{"task_id": "HumanEval_77_iscube", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns True \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\nbool iscube(long a) {\n    if (a == 0) return true;\n    if (a < 0) a = -a;\n    long x = 1;\n    while (x * x * x < a) x += 1;", "canonical_solution": "    return x * x * x == a;", "suffix": "", "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"}
{"task_id": "HumanEval_78_hex_key", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\nlong hex_key(std::string num) {\n  std::set<char> chars({'2', '3', '5', '7', 'B', 'D'});\n  long count = 0;\n  for (auto c : num) {\n    if (chars.find(c) != chars.end()) {\n      count++;\n    }", "canonical_solution": "  }", "suffix": "  return count;", "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"}
{"task_id": "HumanEval_79_decimal_to_binary", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\nstd::string decimal_to_binary(long decimal) {\n  std::string binary(\"db\");\n  if (decimal == 0) {\n    binary.append(\"0db\");\n    return binary;\n  }\n  while (decimal != 0) {\n    binary.append(std::to_string(decimal % 2));\n    decimal /= 2;\n  }", "canonical_solution": "  std::reverse(binary.begin() + 2, binary.end());", "suffix": "  binary.append(\"db\");\n  return binary;", "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"}
{"task_id": "HumanEval_7_filter_by_substring", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of strings only for ones that contain given substring\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> new_vector;\n    for (int i = 0; i < strings.size(); i++) {\n        std::string current_string = strings[i];\n        bool contains_substring = false;\n        for (int j = 0; j < current_string.size(); j++) {\n            std::string current_part = current_string.substr(j, substring.size());\n            if (current_part == substring) {\n                contains_substring = true;\n                break;\n            }\n        }\n        if (contains_substring) {", "canonical_solution": "            new_vector.push_back(current_string);", "suffix": "        }\n    }\n    return new_vector;", "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"}
{"task_id": "HumanEval_81_numerical_letter_grade", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write \n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> results;\n    for (int i = 0; i < grades.size(); i++) {\n        float grade = grades[i];\n        if (grade == (float)4.0) {\n            results.push_back(\"A+\");\n        } else if (grade > (float)3.7) {\n            results.push_back(\"A\");\n        } else if (grade > (float)3.3) {\n            results.push_back(\"A-\");\n        } else if (grade > (float)3.0) {\n            results.push_back(\"B+\");\n        } else if (grade > (float)2.7) {\n            results.push_back(\"B\");\n        } else if (grade > (float)2.3) {\n            results.push_back(\"B-\");\n        } else if (grade > (float)2.0) {\n            results.push_back(\"C+\");\n        } else if (grade > (float)1.7) {\n            results.push_back(\"C\");\n        } else if (grade > (float)1.3) {\n            results.push_back(\"C-\");\n        } else if (grade > (float)1.0) {\n            results.push_back(\"D+\");\n        } else if (grade > (float)0.7) {\n            results.push_back(\"D\");", "canonical_solution": "        } else if (grade > (float)0.0) {", "suffix": "            results.push_back(\"D-\");\n        } else {\n            results.push_back(\"E\");\n        }\n    }\n    return results;", "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"}
{"task_id": "HumanEval_82_prime_length", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns True if the string\n// length is a prime number or False otherwise\n// Examples\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    } else if (length == 2) {", "canonical_solution": "        return true;", "suffix": "    } else {\n        for (int i = 2; i < length; i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }", "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"}
{"task_id": "HumanEval_85_add", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty list of integers lst. add the even elements that are at odd indices..\n// Examples:\nlong add(std::vector<long> lst) {\n\tlong result = 0;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (i % 2 == 1 && lst[i] % 2 == 0) {\n\t\t\tresult += lst[i];\n\t\t}\n\t}", "canonical_solution": "\treturn result;", "suffix": "", "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"}
{"task_id": "HumanEval_86_anti_shuffle", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\nstd::string anti_shuffle(std::string s) {\n    std::string temp;\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    while (ss >> temp) {\n        words.push_back(temp);\n    }\n    std::string ans;\n    for (int i = 0; i < words.size(); i++) {", "canonical_solution": "        std::sort(words[i].begin(), words[i].end());", "suffix": "        ans += words[i];\n        if (i != words.size() - 1) {\n            ans += \" \";\n        }\n    }\n    return ans;", "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"}
{"task_id": "HumanEval_87_get_row", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    std::vector<std::tuple<long, long>> row;\n    int lst_size = lst.size();\n    for (int i = 0; i < lst_size; i++) {\n        int lst_row_size = lst[i].size();\n        for (int j = 0; j < lst_row_size; j++) {\n            if (lst[i][j] == x) {\n                row.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(row.begin(), row.end());\n    int row_size = row.size();\n    for (int i = 0; i < row_size; i++) {\n        int j = i;\n        while (j < row_size && std::get<0>(row[i]) == std::get<0>(row[j])) {", "canonical_solution": "            j++;", "suffix": "        }\n        std::sort(row.begin() + i, row.begin() + j, std::greater<std::tuple<long, long>>());\n        i = j - 1;\n    }\n    return row;", "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"}
{"task_id": "HumanEval_88_sort_array", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given array.\n// Examples:\nstd::vector<long> sort_array(std::vector<long> array) {\n    if(array.size()<=1) return array;\n    if((array[0]+array[array.size()-1])%2==0){\n        std::sort(array.begin(),array.end(),std::greater<int>());\n    }else{\n        std::sort(array.begin(),array.end());", "canonical_solution": "    }", "suffix": "    return array;", "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"}
{"task_id": "HumanEval_89_encrypt", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\nstd::string encrypt(std::string s) {\n    std::string res;\n    for (size_t i = 0; i < s.size(); i++) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            int temp = (s[i] - 'a' + 2 * 2) % 26;\n            res += (char)(temp + 'a');\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {", "canonical_solution": "            int temp = (s[i] - 'A' + 2 * 2) % 26;", "suffix": "            res += (char)(temp + 'A');\n        } else {\n            res += s[i];\n        }\n    }\n    return res;", "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"}
{"task_id": "HumanEval_8_sum_product", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for(auto num : numbers) {", "canonical_solution": "        sum += num;", "suffix": "        product *= num;\n    }\n    return std::make_tuple(sum, product);", "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"}
{"task_id": "HumanEval_90_next_smallest", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the list.\n// Return None if there is no such element.\nstd::optional<long> next_smallest(std::vector<long> lst) {\n\tif (lst.size() == 0)\n\t\treturn std::nullopt;\n\tstd::sort(lst.begin(), lst.end());\n\tfor (int i = 0; i < lst.size() - 1; i++) {\n\t\tif (lst[i] != lst[i + 1])\n\t\t\treturn lst[i + 1];", "canonical_solution": "\t}", "suffix": "\treturn std::nullopt;", "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"}
{"task_id": "HumanEval_91_is_bored", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\nlong is_bored(std::string S) {\n  int count = 0;\n  std::istringstream ss(S);\n  std::string token;\n  std::vector<std::string> result;\n  while (std::getline(ss, token, '.')) {\n    std::vector<std::string> words;\n    std::istringstream iss(token);\n    std::string word;\n    while (iss >> word)", "canonical_solution": "      words.push_back(word);", "suffix": "    if(words.size() > 0)\n      if(words[0] == \"I\")\n        count++;\n  }\n  return count;", "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"}
{"task_id": "HumanEval_93_encode", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\nstd::string encode(std::string message) {\n\tstd::string result = \"\";\n\tfor (char& c : message) {\n\t\tif (c >= 'a' && c <= 'z') {\n\t\t\tresult += toupper(c);", "canonical_solution": "\t\t} else if (c >= 'A' && c <= 'Z') {", "suffix": "\t\t\tresult += tolower(c);\n\t\t} else {\n\t\t\tresult += c;\n\t\t}\n\t}\n\tstd::vector<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\tfor (int i = 0; i < result.length(); i++) {\n\t\tfor (char v : vowels) {\n\t\t\tif (result[i] == v) {\n\t\t\t\tresult[i] = 'a' + (result[i] - 'a' + 2) % 26;\n\t\t\t} else if (result[i] == toupper(v)) {\n\t\t\t\tresult[i] = 'A' + (result[i] - 'A' + 2) % 26;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;", "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"}
{"task_id": "HumanEval_94_skjkasdkd", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\nlong skjkasdkd(std::vector<long> lst) {\n    // your code here\n    int a[lst.size()];\n    for(int i=0;i<lst.size();i++)\n        a[i]=lst[i];\n    int p=0;\n    for(int i=0;i<lst.size();i++)\n    {\n        int flag=0;\n        for(int j=2;j<=a[i]/2;j++)\n        {\n            if(a[i]%j==0)", "canonical_solution": "            {", "suffix": "                flag=1;\n                break;\n            }\n        }\n        if(flag==0 && a[i]!=1)\n        {\n            if(a[i]>p)\n                p=a[i];\n        }\n    }\n    int sum=0;\n    while(p!=0)\n    {\n        sum+=p%10;\n        p=p/10;\n    }\n    return sum;", "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"}
{"task_id": "HumanEval_95_check_dict_case", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return True if all keys are strings in lower \n// case or all keys are strings in upper case, else return False.\n// The function should return False is the given dictionary is empty.\n// Examples:\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  bool up=true,low=true;\n  if(dict.size()==0) return false;\n  if(dict.begin()->first[0]>='A' && dict.begin()->first[0]<='Z')\n    up=true;\n  else low=true;\n  for(auto i=dict.begin();i!=dict.end();i++){\n    for(int j=0;j<i->first.size();j++){\n      if(i->first[j]>='A' && i->first[j]<='Z'){\n        low=false;\n      }\n      else if(i->first[j]>='a' && i->first[j]<='z'){\n        up=false;\n      }\n      else\n        return false;\n    }\n  }\n  if(up || low)\n    return true;", "canonical_solution": "  else", "suffix": "    return false;", "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"}
{"task_id": "HumanEval_96_count_up_to", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\nstd::vector<long> count_up_to(long n) {\n\tstd::vector<long> vec;\n\tif (n > 1) {\n\t\tvec.push_back(2);\n\t\tfor (long i = 3; i < n; i++) {\n\t\t\tbool isPrime = true;\n\t\t\tfor (long j = 2; j < i; j++) {\n\t\t\t\tif (i % j == 0) {", "canonical_solution": "\t\t\t\t\tisPrime = false;", "suffix": "\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isPrime)\n\t\t\t\tvec.push_back(i);\n\t\t}\n\t}\n\treturn vec;", "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"}
{"task_id": "HumanEval_97_multiply", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\nlong multiply(long a, long b) {\n    int c = abs(a % 10);\n    int d = abs(b % 10);", "canonical_solution": "    return c * d;", "suffix": "", "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"}
{"task_id": "HumanEval_98_count_upper", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\nlong count_upper(std::string s) {\n\tlong count = 0;\n\tstd::string c;\n\tfor (long i = 0; i < s.length(); i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tc = s[i];\n\t\t\tif (c == \"A\" || c == \"E\" || c == \"I\" || c == \"O\" || c == \"U\") {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}", "canonical_solution": "\t}", "suffix": "\treturn count;", "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"}
{"task_id": "HumanEval_99_closest_integer", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {", "canonical_solution": "    double num = std::stod(value);", "suffix": "    return std::lround(num);", "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"}
{"task_id": "HumanEval_9_rolling_max", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result((int)numbers.size());\n    std::stack<long> st;\n    for (int i = 0; i < (int)numbers.size(); i++) {\n        while ((int)st.size() > 0 && numbers[st.top()] <= numbers[i]) {\n            st.pop();\n        }\n        if ((int)st.size() == 0) {\n            result[i] = numbers[i];\n        } else {", "canonical_solution": "            result[i] = result[st.top()];", "suffix": "        }\n        st.push(i);\n    }\n    return result;", "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"}
